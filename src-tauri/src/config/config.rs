use std::path::PathBuf;

use anyhow::{anyhow, Ok, Result};
use once_cell::sync::OnceCell;

use crate::utils::{dirs, help};

use super::{motrix::IMotrix, runtime::IRuntime, Draft};

pub const RUNTIME_CONFIG: &str = "tauri-motrix.yaml";
pub const CHECK_CONFIG: &str = "tauri-motrix-check.yaml";

pub struct Config {
    motrix_config: Draft<IMotrix>,
    runtime_config: Draft<IRuntime>,
}

impl Config {
    pub fn global() -> &'static Config {
        static CONFIG: OnceCell<Config> = OnceCell::new();

        CONFIG.get_or_init(|| Config {
            motrix_config: Draft::from(IMotrix::new()),
            runtime_config: Draft::from(IRuntime::new()),
        })
    }

    pub async fn init_config() -> Result<()> {
        // TODO
        Ok(())
    }

    pub fn motrix() -> Draft<IMotrix> {
        Self::global().motrix_config.clone()
    }

    pub fn runtime() -> Draft<IRuntime> {
        Self::global().runtime_config.clone()
    }

    pub fn generate_file(typ: ConfigType) -> Result<PathBuf> {
        let path = match typ {
            ConfigType::Run => dirs::app_home_dir()?.join(RUNTIME_CONFIG),
            ConfigType::Check => dirs::app_home_dir()?.join(CHECK_CONFIG),
        };

        let runtime = Config::runtime();
        let runtime = runtime.latest();

        let config = runtime
            .config
            .as_ref()
            .ok_or(anyhow!("failed to get runtime config"))?;

        help::save_yaml(&path, &config, Some("# Generated by Motrix"))?;
        Ok(path)
    }
}

#[derive(Debug)]
pub enum ConfigType {
    Run,
    Check,
}
